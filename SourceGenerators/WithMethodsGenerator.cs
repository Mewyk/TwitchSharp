using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TwitchSharp.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class WithMethodsGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "TwitchSharp.Generators.GenerateWithMethodsAttribute";

    private const string AttributeSource = """
        // <auto-generated />
        #nullable enable

        namespace TwitchSharp.Generators;

        /// <summary>
        /// Marks a partial record for automatic generation of fluent With*() and Add*() methods.
        /// </summary>
        [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
        internal sealed class GenerateWithMethodsAttribute : global::System.Attribute
        {
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static initializationContext =>
            initializationContext.AddSource("GenerateWithMethodsAttribute.g.cs", AttributeSource));

        var targets = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeFullName,
                static (node, _) => node is RecordDeclarationSyntax,
                static (attributeContext, _) => GetTargetInfo(attributeContext));

        context.RegisterSourceOutput(targets, static (sourceProductionContext, targetInfo) =>
        {
            if (targetInfo is null)
                return;

            var source = GenerateWithMethods(targetInfo);
            sourceProductionContext.AddSource($"{targetInfo.TypeName}.WithMethods.g.cs", source);
        });
    }

    private static TargetInfo? GetTargetInfo(GeneratorAttributeSyntaxContext context)
    {
        var symbol = context.TargetSymbol as INamedTypeSymbol;
        if (symbol is null)
            return null;

        var namespaceName = symbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : symbol.ContainingNamespace.ToDisplayString();

        var properties = new List<PropertyInfo>();
        foreach (var member in symbol.GetMembers())
        {
            if (member is not IPropertySymbol property)
                continue;

            if (property.DeclaredAccessibility != Accessibility.Public)
                continue;

            if (property.SetMethod is null || !property.SetMethod.IsInitOnly)
                continue;

            var typeName = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isArray = property.Type is IArrayTypeSymbol;
            string? elementTypeName = null;

            if (isArray && property.Type is IArrayTypeSymbol arrayType)
            {
                elementTypeName = arrayType.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }

            properties.Add(new PropertyInfo(
                property.Name,
                typeName,
                isArray,
                elementTypeName,
                property.Type.NullableAnnotation == NullableAnnotation.Annotated));
        }

        if (properties.Count == 0)
            return null;

        var accessModifiers = symbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            _ => "public"
        };

        return new TargetInfo(
            namespaceName,
            symbol.Name,
            accessModifiers,
            symbol.IsSealed,
            properties.ToArray());
    }

    private static string GenerateWithMethods(TargetInfo targetInfo)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("// <auto-generated />");
        stringBuilder.AppendLine("#nullable enable");
        stringBuilder.AppendLine();

        if (targetInfo.Namespace is not null)
        {
            stringBuilder.Append("namespace ");
            stringBuilder.Append(targetInfo.Namespace);
            stringBuilder.AppendLine(";");
            stringBuilder.AppendLine();
        }

        stringBuilder.Append(targetInfo.AccessModifiers);
        if (targetInfo.IsSealed)
            stringBuilder.Append(" sealed");
        stringBuilder.Append(" partial record ");
        stringBuilder.AppendLine(targetInfo.TypeName);
        stringBuilder.AppendLine("{");

        for (var index = 0; index < targetInfo.Properties.Length; index++)
        {
            var property = targetInfo.Properties[index];

            // With method
            stringBuilder.Append("    /// <summary>Creates a copy with <see cref=\"");
            stringBuilder.Append(property.Name);
            stringBuilder.AppendLine("\"/> set to the specified value.</summary>");
            stringBuilder.Append("    public ");
            stringBuilder.Append(targetInfo.TypeName);
            stringBuilder.Append(" With");
            stringBuilder.Append(property.Name);
            stringBuilder.Append('(');
            stringBuilder.Append(property.TypeName);
            stringBuilder.Append(" value) => this with { ");
            stringBuilder.Append(property.Name);
            stringBuilder.AppendLine(" = value };");

            // Add method for array properties
            if (property.IsArray && property.ElementTypeName is not null)
            {
                stringBuilder.AppendLine();
                stringBuilder.Append("    /// <summary>Creates a copy with additional items appended to <see cref=\"");
                stringBuilder.Append(property.Name);
                stringBuilder.AppendLine("\"/>.</summary>");
                stringBuilder.Append("    public ");
                stringBuilder.Append(targetInfo.TypeName);
                stringBuilder.Append(" Add");
                stringBuilder.Append(property.Name);
                stringBuilder.Append("(params ");
                stringBuilder.Append(property.ElementTypeName);
                stringBuilder.Append("[] values) => this with { ");
                stringBuilder.Append(property.Name);
                stringBuilder.Append(" = [.. ");
                stringBuilder.Append(property.Name);
                if (property.IsNullable)
                    stringBuilder.Append(" ?? []");
                stringBuilder.AppendLine(", .. values] };");
            }

            if (index < targetInfo.Properties.Length - 1)
                stringBuilder.AppendLine();
        }

        stringBuilder.AppendLine("}");

        return stringBuilder.ToString();
    }
}

internal sealed class TargetInfo
{
    public string? Namespace { get; }
    public string TypeName { get; }
    public string AccessModifiers { get; }
    public bool IsSealed { get; }
    public PropertyInfo[] Properties { get; }

    public TargetInfo(string? namespaceName, string typeName, string accessModifiers, bool isSealed, PropertyInfo[] properties)
    {
        Namespace = namespaceName;
        TypeName = typeName;
        AccessModifiers = accessModifiers;
        IsSealed = isSealed;
        Properties = properties;
    }
}

internal sealed class PropertyInfo
{
    public string Name { get; }
    public string TypeName { get; }
    public bool IsArray { get; }
    public string? ElementTypeName { get; }
    public bool IsNullable { get; }

    public PropertyInfo(string name, string typeName, bool isArray, string? elementTypeName, bool isNullable)
    {
        Name = name;
        TypeName = typeName;
        IsArray = isArray;
        ElementTypeName = elementTypeName;
        IsNullable = isNullable;
    }
}
